<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NodeJS</title>
    <url>/2019/11/02/NodeJS/</url>
    <content><![CDATA[<p><img src="https://blog-1257820412.cos.ap-shanghai.myqcloud.com/title/half_year.jpg" alt="pic"></p>
<a id="more"></a>

<h2 id="Node-js-概述"><a href="#Node-js-概述" class="headerlink" title="Node.js 概述"></a>Node.js 概述</h2><ul>
<li><p>Node.js 是JavaScript运行时环境</p>
</li>
<li><p>可以解析执行JavaScript代码</p>
</li>
<li><p>没有BOM 、DOM</p>
</li>
<li><p>遵循EcmaScript</p>
</li>
<li><p>为JavaScript提供了服务器级别的操作API</p>
</li>
<li><p>构建与Chrome的V8引擎之上</p>
<ul>
<li><p>Google Chrome 中的V8引擎世界上公认的解析执行JavaScript代码最快的</p>
</li>
<li><p>Node.js作者把Google Chrome 中的V8引擎移出来，开发了独立的JavaScript运行时环境</p>
</li>
</ul>
</li>
</ul>
<h2 id="Node-js-特性"><a href="#Node-js-特性" class="headerlink" title="Node.js 特性"></a>Node.js 特性</h2><ul>
<li><p>event-driven 事件驱动</p>
</li>
<li><p>non-blocking I/O model 非阻塞IO模型（异步）</p>
</li>
<li><p>lightweight and efficient 轻量和高效</p>
</li>
</ul>
<h2 id="Node-js-功能"><a href="#Node-js-功能" class="headerlink" title="Node.js 功能"></a>Node.js 功能</h2><ul>
<li><p>WEB服务器后台</p>
<ul>
<li><p>B/S编程模型（与语言无关）</p>
</li>
<li><p>模块化编程 （类似less  @import(‘文件路径’)  引用加载文件）</p>
</li>
<li><p>异步编程</p>
<ul>
<li>promise</li>
<li>async</li>
<li>generator </li>
</ul>
</li>
<li><p>Express Web开发框架</p>
</li>
<li><p>Ecmascript 6</p>
</li>
</ul>
</li>
<li><p>命令行工具</p>
<ul>
<li>git    （ C ）</li>
<li>npm（ Node ）</li>
<li>hexo（ Node ）</li>
</ul>
</li>
</ul>
<h2 id="Node-js-基本操作"><a href="#Node-js-基本操作" class="headerlink" title="Node.js 基本操作"></a>Node.js 基本操作</h2><h3 id="执行文件"><a href="#执行文件" class="headerlink" title="执行文件"></a>执行文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建编写js脚本文件</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 打开终端，定位到脚本文件所属目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 输入node '文件名' 执行对应的文件  -- 文件名不能以node.js命名否则会打开这个文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">node begin.js</span></span><br></pre></td></tr></table></figure>



<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 执行文件操作必须引入fs这个核心模块（file-system）</span></span><br><span class="line"><span class="comment">// 使用 require 方法载入fs核心模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'url'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,data</span>)</span>&#123;   <span class="comment">// URL：要读取的文件路径 （统一资源定位符）</span></span><br><span class="line">	<span class="keyword">if</span>(error)&#123;</span><br><span class="line">	 	<span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 读取成功 error 返回 null   ，data 返回 数据									</span></span><br><span class="line"><span class="comment">// 读取失败 error 返回 错误对象，data 返回 undefined</span></span><br><span class="line"></span><br><span class="line">## ps: data 返回的数据是将文件存储的二进制数据 转为 十六进制数据，展现</span><br><span class="line">##	   可以用 toString 方法转为 字符串</span><br><span class="line"></span><br><span class="line">## readFile 的第二个参数是可选的，传入 utf8 就是告诉他把读取到的文件直接按照 utf8 编码转成字符串</span><br><span class="line">## 等价于 data.toString()</span><br></pre></td></tr></table></figure>



<h3 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readdir(<span class="string">'url'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>) </span>&#123;  <span class="comment">// files: 返回数组</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    res.end(err.message) <span class="comment">// err对象 中有一个属性 message </span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(files)  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.writeFile(<span class="string">'url'</span>,<span class="string">'content'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123; <span class="comment">// content: 写入文件内容   error: 形参</span></span><br><span class="line">     <span class="keyword">if</span>(error)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'写入失败'</span>)</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'写入成功'</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">## 写入成功 error 返回 null</span><br><span class="line">## 写入失败 error 返回 错误对象</span><br></pre></td></tr></table></figure>



<h3 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Node中有一个核心模块 http ,职责创建编写服务器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载http核心模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用http.createServer() 方法创建web服务    ## 返回一个Server实例</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受请求</span></span><br><span class="line"><span class="comment">// 处理请求</span></span><br><span class="line"><span class="comment">// 返回响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 request 请求事件</span></span><br><span class="line"><span class="comment">// 当客户端请求时，自动触发服务器的 request 请求事件，然后执行第二个参数：回调处理函数 </span></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'收到请求,请求路径'</span> + request.url) </span><br><span class="line">    response.write(<span class="string">'hello'</span>)</span><br><span class="line">    response.write(<span class="string">' node.js'</span>)</span><br><span class="line">    response.end()</span><br><span class="line">  	<span class="comment">// 简化</span></span><br><span class="line">  	response.end(<span class="string">'hello node.js'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">## request  请求事件处理函数，需接收两个参数：</span><br><span class="line">## Request  请求对象（获取客户端请求信息：如请求路径）</span><br><span class="line">						## req.url 获取端口号以后的路径，所有url都是以 / 开头的 默认为 /</span><br><span class="line">## Response 响应对象（给客户端发送响应信息）有 writer方法 ：给客户端发送响应数据</span><br><span class="line">						## writer方法 ：给客户端发送响应数据</span><br><span class="line">            ## write 可以使用多次，但是最后一定要使用end结束响应，否则客户端会一直等待。</span><br><span class="line">            ## 简化操作 直接end的同时发送响应数据 response.end('str')</span><br><span class="line">            ## response.end()支持两种数据类型：二进制 字符串</span><br><span class="line">            </span><br><span class="line">## response.end()	一次请求对应一次响应，响应结束这次请求也结束  不执行后续代码  类似return</span><br><span class="line">## response.end() 必须存在</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定端口号，启动服务器。</span></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务器启动成功，可以通过 http://127.0.0.1:3000/，进行访问'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时终端被服务占用，关闭终端即关闭服务器（X掉，或者 Ctrl+c 终止），有响应便返回响应</span></span><br></pre></td></tr></table></figure>



<h4 id="创建服务简写"><a href="#创建服务简写" class="headerlink" title="- 创建服务简写"></a>- 创建服务简写</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">http</span><br><span class="line">		.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">		&#125;)</span><br><span class="line">		.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  		<span class="built_in">console</span>.log(<span class="string">'Server is running'</span>)</span><br><span class="line">		&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h3><ul>
<li>采用URL模块，获取</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj =url.parse(<span class="string">'http://127.0.0.1:3000/post?name=fasdf&amp;mes= asdf'</span>, <span class="literal">true</span>)</span><br><span class="line">														<span class="comment">// true： 可以让里面的query 将所传入的参数转为对象</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line">$</span><br><span class="line">  protocol: <span class="string">'http:'</span>,	<span class="comment">// 协议</span></span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="literal">null</span>,</span><br><span class="line">  host: <span class="string">'127.0.0.1:3000'</span>,  </span><br><span class="line">  port: <span class="string">'3000'</span>,	<span class="comment">// 端口号</span></span><br><span class="line">  hostname: <span class="string">'127.0.0.1'</span>,	<span class="comment">// 主机名</span></span><br><span class="line">  hash: <span class="literal">null</span>,</span><br><span class="line">  search: <span class="string">'?name=fasdf&amp;mes=%20asdf'</span>,	<span class="comment">// 查询字符串（ GET参数 ）</span></span><br><span class="line">  query: [<span class="built_in">Object</span>: <span class="literal">null</span> prototype] &#123; <span class="attr">name</span>: <span class="string">'fasdf'</span>, <span class="attr">mes</span>: <span class="string">' asdf'</span> &#125;,</span><br><span class="line">  pathname: <span class="string">'/post'</span>,</span><br><span class="line">  path: <span class="string">'/post?name=fasdf&amp;mes=%20asdf'</span>,</span><br><span class="line">  href: <span class="string">'http://127.0.0.1:3000/post?name=fasdf&amp;mes=%20asdf'</span> &#125;</span><br></pre></td></tr></table></figure>





<h2 id="Node-js-中-的-JavaScript"><a href="#Node-js-中-的-JavaScript" class="headerlink" title="Node.js 中 的 JavaScript"></a>Node.js 中 的 JavaScript</h2><ul>
<li>EcmaScript</li>
<li>核心模块</li>
<li>第三方模块</li>
<li>用户自定义模块</li>
</ul>
<h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>Node为JavaScript提供了很多服务器级别的API，而且这些API绝大多数都被包装到了一个具名的核心模块中。他们都有自己特殊的名称标识，若要使用这些模块，必须用  <strong><em>require</em></strong>  加载模块。</p>
<ul>
<li>文件操作的核心模块：fs</li>
<li>服务构建的核心模块：http</li>
<li>路径处理的核心模块：path</li>
<li>路径操作的核心模块：url</li>
<li>操作系统信息的核心模块：os</li>
<li>…</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(path.extname(<span class="string">'url'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回扩展名 .txt</span></span><br></pre></td></tr></table></figure>



<h3 id="用户定义模块"><a href="#用户定义模块" class="headerlink" title="用户定义模块"></a>用户定义模块</h3><h4 id="require-方法"><a href="#require-方法" class="headerlink" title="require  方法"></a>require  方法</h4><p>​    <strong>用来加载模块，并执行里面的代码</strong>（ 可加载执行多个JavaScript脚本文件 ）</p>
<p>​    <strong>拿到被加载文件模块导出的接口对象</strong></p>
<ul>
<li><p>node中模块分三种</p>
<ul>
<li><p>具名的核心模块 （ fs 、http …）</p>
</li>
<li><p>用户编写的文件模块</p>
<p>​    相对路径必须加 ./ 或 ../    （ ./ 不能省略，否则报错）</p>
<p>​    可以省略后缀名</p>
</li>
<li><p>第三方模块</p>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js =&gt; stat'</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js =&gt; end'</span>)</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>node中没有全局作用域，只有模块作用域（即文件作用域）</p>
<ul>
<li>模块是完全封闭的<ul>
<li>文件与文件之间可以完全避免变量命名冲突、污染问题</li>
<li>外部访问不到内部，内部访问不到外部</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="exports-对象"><a href="#exports-对象" class="headerlink" title="exports 对象"></a>exports 对象</h4><p><strong>每个文件模块都提供了  <em>exports</em>  对象 （ 默认是空对象 ）</strong></p>
<ul>
<li><p>由于node只有模块作用域，想要做到模块间通信需要用到  <strong><em>exports</em></strong></p>
</li>
<li><p>把需要被外部访问的成员手动挂载到 <strong><em>exports</em></strong> 接口对象中</p>
</li>
<li><p>多次在 <strong>exports</strong> 添加成员，实现对外导出多个内部成员</p>
</li>
<li><p>哪个文件 <strong><em>require</em></strong> 这个的模块，就可以得到模块内部的   <strong><em>exports</em></strong>  接口对象</p>
<ul>
<li>即：<strong><em>require</em></strong>  的返回值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## └─ducument</span><br><span class="line">##    ├─a.js</span><br><span class="line">##    └─b.js</span><br><span class="line"></span><br><span class="line">## ----  b.js content</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'1231234'</span></span><br><span class="line">exports.foo = foo</span><br><span class="line"></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line"></span><br><span class="line">## ----  a.js content</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bExports = <span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bExports.foo)</span><br><span class="line"><span class="built_in">console</span>.log(bExports.add(<span class="number">10</span>, <span class="number">210</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个模块需要直接导出某个成员，而非挂载的方式必须使用</p>
<p><code>module.exports = add</code></p>
<ul>
<li>add 可为 function，string， array。。都可以</li>
</ul>
</li>
</ul>
<h2 id="Web-服务端开发"><a href="#Web-服务端开发" class="headerlink" title="Web 服务端开发"></a>Web 服务端开发</h2><h3 id="IP地址-与-端口号"><a href="#IP地址-与-端口号" class="headerlink" title="IP地址  与  端口号"></a>IP地址  与  端口号</h3><ul>
<li><p>所有联网的程序都要进行网络通信</p>
</li>
<li><p>计算机中只有一个物理网卡，且同一个局域网中的网卡地址必须唯一。</p>
</li>
<li><p>网卡是通过唯一的ip地址进行定位</p>
</li>
</ul>
<p><strong>IP 地址用来定位计算机</strong></p>
<p><strong>端口号用来定位应用程序</strong></p>
<ul>
<li>所有需要网络通信的软件都必须有端口号</li>
<li>端口号使用范围 0 ~ 65536 之间</li>
<li>计算机中有一些默认端口号 尽量不去使用 ex : 80 ..</li>
<li>一台计算机，同一个端口号在同一时间，只能被一个 </li>
<li>Node.js 可以开启多个服务，但是一定确保不同服务占用不同端口号</li>
</ul>
<h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><ul>
<li><p>服务端发送的数据默认，是utf-8编码的</p>
</li>
<li><p>浏览器在不知道服务器响应内容的编码的情况下，会按照当前操作系统默认的编码去解析</p>
<ul>
<li>中文操作系统默认编码是 GBK</li>
<li>在http协议中 Content-Type是用来告知，对方给你发送数据内容的数据类型</li>
<li>图片不需要指定编码，常说的编码一般指的是：字符编码，一般只为字符数据指定编码</li>
</ul>
</li>
<li><p><strong>通过设置响应头的方式设置Content-Type的方式解决乱码问题</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'text/plain; charset=utf-8'</span>)</span><br><span class="line">    res.end(<span class="string">'hello 世界'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器最好把每次响应的数据是什么内容类型 ，正确的告诉客户端</li>
<li>不同的资源对应的 Content-Type 是不一样，具体参照：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">http://tool.oschina.net/commons</a></li>
<li>对于文本类型的数据，最好都加上编码，目的是为了防止中文解析乱码问题</li>
</ul>
</li>
</ul>
<ul>
<li>除了用 Content-Type 指定编码，也可以在HTML页面，通过meta元数据（用来 描述、特征、信息，存储内容的数据）来声明当前文本的编码格式</li>
</ul>
<h3 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h3><ul>
<li><p>当浏览器收到HTML的响应内容以后，开始从上到下一次解析，</p>
</li>
<li><p>在解析过程中若发现</p>
<ul>
<li>link</li>
<li>script</li>
<li>img</li>
<li>iframe</li>
<li>video</li>
<li>audio</li>
</ul>
</li>
<li><p>等带有src href属性标签的时候，浏览器会自动对这些资源发起新的请求</p>
</li>
</ul>
<h3 id="统一资源管理"><a href="#统一资源管理" class="headerlink" title="统一资源管理"></a>统一资源管理</h3><ul>
<li>为了方便统一处理静态资源，顾将静态资源存放在同一位置</li>
<li>通过代码灵活控制那些资源能被访问，那些资源不允许访问</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = req.url</span><br><span class="line">    <span class="keyword">if</span> (url === <span class="string">'/'</span>) &#123;</span><br><span class="line">      fs.readFile(<span class="string">'./view/index.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          res.end(<span class="string">'404 Not Found'</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.end(data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.indexOf(<span class="string">'/public/'</span>) === <span class="number">0</span>) &#123;   <span class="comment">// public 开启访问权限</span></span><br><span class="line">      fs.readFile(<span class="string">'.'</span> + url, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          res.end(<span class="string">'404 Not Found'</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.end(data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Server is running'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>上个实例，只有public目录可以提供访问，灵活控制访问资源</li>
</ul>
<h3 id="服务器重定向"><a href="#服务器重定向" class="headerlink" title="服务器重定向"></a>服务器重定向</h3><ul>
<li><p>状态码设置 302临时重定向</p>
<ul>
<li>301为永久重定向 浏览器会记住</li>
<li>a  =&gt; b ,下次请求a，不经过a 直接到b</li>
<li>302为临时重定向 浏览器会记住<ul>
<li>a  =&gt; b ,下次继续请求a，a  =&gt; b</li>
</ul>
</li>
<li>response.statusCode = 302</li>
</ul>
</li>
<li><p>响应头中通过 Location告诉客户端往哪重定向</p>
<ul>
<li>response.setHeader( ‘Location’,  ‘/‘ )</li>
</ul>
</li>
<li><p>客户端发现收到的服务器的响应状态码是302，会自动在响应头中找 Location，然后对改地址发起新的请求。</p>
</li>
<li><p>客户端自动跳转</p>
</li>
</ul>
<h2 id="Node中的模块系统"><a href="#Node中的模块系统" class="headerlink" title="Node中的模块系统"></a>Node中的模块系统</h2><h3 id="前-提"><a href="#前-提" class="headerlink" title="前 提"></a>前 提</h3><ul>
<li>使用Node编写应用程序主要是使用<ul>
<li>EcamScript 语言</li>
<li>核心模块</li>
<li>第三方模块</li>
<li>用户自定义模块</li>
</ul>
</li>
</ul>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul>
<li><p>文件作用域</p>
</li>
<li><p>通信规则</p>
<ul>
<li><p>加载</p>
</li>
<li><p>导出</p>
</li>
</ul>
</li>
</ul>
<h3 id="CommonJS模块规范"><a href="#CommonJS模块规范" class="headerlink" title="CommonJS模块规范"></a>CommonJS模块规范</h3><p>JavaScript本身并不支持模块化 在Node中不仅支持，还有一个很重要的概念  <strong>模块系统</strong></p>
<ul>
<li>模块作用域<ul>
<li>默认模块中任何内容不能被外部访问</li>
</ul>
</li>
<li>使用require方法加载模块</li>
<li>使用exports接口对象导出模块中的成员</li>
</ul>
<h4 id="加载-require"><a href="#加载-require" class="headerlink" title="加载  require"></a>加载  <code>require</code></h4><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> custom = <span class="built_in">require</span>(<span class="string">'module'</span>)</span><br></pre></td></tr></table></figure>

<h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><ol>
<li>执行被加载模块中代码</li>
<li>得到被加载模块中的  <code>exports</code>  导出接口对象</li>
</ol>
<h5 id="加载规则："><a href="#加载规则：" class="headerlink" title="加载规则："></a>加载规则：</h5><p>模块查找机制：优先从缓存加载    =&gt;  核心模块  =&gt;  路径形式文件模块  =&gt;  第三方模块</p>
<h6 id="优先从缓存加载"><a href="#优先从缓存加载" class="headerlink" title="优先从缓存加载"></a>优先从缓存加载</h6><ul>
<li><p>优先从缓存加载，不会重复加载，目的是为了避免重复加载，提高模块加载效率</p>
</li>
<li><p>可以拿到其中的接口对象，但是不会重复执行里面的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## └─ducument</span><br><span class="line">##    ├─a.js</span><br><span class="line">##    ├─b.js</span><br><span class="line">##    └─main.js</span><br><span class="line"></span><br><span class="line">## ----  main.js content</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line"><span class="keyword">var</span> fn = <span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fn)</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line">## ----  a.js content</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js 被加载了'</span>)</span><br><span class="line"><span class="keyword">var</span> fn = <span class="built_in">require</span>(<span class="string">'./b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fn)</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line">## ----  b.js content</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js 被加载了'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello bbb'</span>)</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line">## ----	 main.js输出结果</span><br><span class="line">a.js 被加载了</span><br><span class="line">b.js 被加载了</span><br><span class="line">[<span class="built_in">Function</span>]</span><br><span class="line">[<span class="built_in">Function</span>]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h6 id="判断模块模块标识-符"><a href="#判断模块模块标识-符" class="headerlink" title="判断模块模块标识(符)"></a>判断模块模块标识(符)</h6><p><strong>require(‘模块标识’)</strong></p>
<ul>
<li>核心模块<ul>
<li>本质：文件。</li>
<li>已被编译到了二进制文件中，只需要按名字加载即可</li>
<li>模块标识 ：模块名</li>
</ul>
</li>
<li>第三方模块<ul>
<li>凡是第三方模块必须通过npm下载，通过require(‘包名’)进行加载使用</li>
<li>不可能有一个第三方包 与 核心模块 重名</li>
<li>模块标识 ：模块名</li>
</ul>
</li>
<li>用户模块<ul>
<li>模块标识 ：路径</li>
</ul>
</li>
</ul>
<p><strong>路径形式的模块</strong>：</p>
<ul>
<li>.js     后缀名可以省略</li>
<li>./      当前目录 （不可省略）</li>
<li>../     上一级目录 （不可省略）</li>
<li>/xxx    绝对路径 ( 首位的  / 表示当前文件模块所属磁盘根路径)  ==&gt;  几乎不用</li>
<li>d:/xxxx  绝对路径   ==&gt;  几乎不用 </li>
</ul>
<p><strong>既不是核心模块，也不是路径形式的模块</strong></p>
<ol>
<li>模块加载规则<ul>
<li>先找到当前文件所属目录中的 <code>node_modules</code> 目录    ( 以art-template 为例 )</li>
<li>== &gt;     node_modules/art-template</li>
<li>== &gt;     node_modules/art-template/package.json 文件</li>
<li>== &gt;     node_modules/art-template/package.json 文件中的 main 属性</li>
<li>main属性记录了art-template的入口模块 </li>
<li>加载使用art-template</li>
<li>实际上最终加载的还是文件</li>
</ul>
</li>
<li>特殊情况<ul>
<li>如果 package.json 文件不存在或者 main指定的入口模块也没有，则 node 会找该目录下的 index.js<ul>
<li>index.js 会作为默认备选项</li>
</ul>
</li>
<li>若所述所有条件均不成立，则会进人上一级目录中的 node_modules 目录执行查找</li>
<li>若上一级还没有，则继续往上上一级查找</li>
<li>。。。</li>
<li>如果直到当前磁盘根目录还找不到，最后报错  <code>can not find module xxx</code> </li>
</ul>
</li>
</ol>
<p><strong>在项目中有且只有一个 <code>node_modules</code> ，不会出现多个</strong></p>
<p><strong>位置：放在项目根目录中，这样项目中所有子目录中的代码都可以加载第三方包</strong></p>
<h4 id="导出-exports"><a href="#导出-exports" class="headerlink" title="导出 exports"></a>导出 <code>exports</code></h4><ul>
<li><p>Node中是模块作用域，默认文件中所有成员只在当前文件模块有效</p>
</li>
<li><p>想要做到模块间通信需要用到  <code>exports</code> ，把需要被外部访问的成员手动挂载到 <code>exports</code> 接口对象中</p>
<ul>
<li><p>导出多个成员（必须在对象中）：</p>
<ul>
<li><p>多次在 <code>exports</code> 添加成员，实现对外导出多个内部成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.a = <span class="number">123</span></span><br><span class="line">exports.b = <span class="string">'string'</span></span><br><span class="line">exports.c =	<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'string'</span>)</span><br><span class="line">&#125;</span><br><span class="line">exports.d = &#123;</span><br><span class="line">  foo = <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>导出单个成员（拿到的是函数、字符串、数组。。。）：</p>
<ul>
<li><p>一个模块需要直接导出单个成员，而非挂载的方式必须使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">'string'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若重复使用，则后者覆盖前者</p>
</li>
<li><p>也可以用 <code>module.exports =</code> 的操作导出多个成员</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> add: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x + y</span><br><span class="line"> &#125;,</span><br><span class="line"> str: <span class="string">'string'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul>
<li><p>在Node 中，每一个模块内部都有一个自己的 <code>module</code> 对象</p>
</li>
<li><p>该 <code>module</code> 对象中，有一个成员叫： <code>exports</code> 也是一个对象（ 默认为空 ）</p>
</li>
<li><p>若需要对外导出成员，只需要把导出的成员挂载到 <code>module.exports</code> 中</p>
</li>
<li><p>由于每次导出接口成员的时候都通过 <code>module.exports.xxx = xxx</code> 比较麻烦，node为了简化操作专门提供一个变量 <code>exports</code>  等价于  <code>module.exports</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(exports === <span class="built_in">module</span>.exports)	<span class="comment">// =&gt; true</span></span><br><span class="line">exports.foo = <span class="string">'bar'</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="built_in">module</span>.exports.add = <span class="string">'bar'</span></span><br></pre></td></tr></table></figure>

<p>固（混搭）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.foo = <span class="string">'bar'</span></span><br><span class="line"><span class="built_in">module</span>.exports.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line"><span class="comment">// require结果</span></span><br><span class="line">&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">add</span>: [<span class="built_in">Function</span>] &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个模块需要导出单个成员的时候</p>
<ul>
<li><p>不能使用：<code>exports = &#39;string&#39;</code> </p>
<ul>
<li><code>exports</code> 仅仅只是 <code>module.exports</code>  的引用,底层最后的代码是：<ul>
<li><code>var exports = module.exports</code></li>
<li><code>return module.exports</code></li>
</ul>
</li>
<li>重新赋值不再指向 <code>module.exports</code> , 便丢失了引用关系 </li>
<li>只是快捷方式，可以忽略</li>
</ul>
</li>
<li><p>只能使用：<code>module.exports = &#39;string&#39;</code></p>
<ul>
<li><p>重新赋值以后 <code>exports</code> 便直接失效。</p>
<ol>
<li>底层代码：<code>return module.exports</code></li>
<li>将对象赋值给变量，所存放的是地址</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">'string'</span></span><br><span class="line">exports.foo = <span class="string">'bar'</span></span><br><span class="line">-------------</span><br><span class="line"><span class="comment">// require结果</span></span><br><span class="line"><span class="string">'string'</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="底层代码模拟"><a href="#底层代码模拟" class="headerlink" title="底层代码模拟"></a>底层代码模拟</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">	exports: &#123; </span><br><span class="line">	&#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 哪个文件 require 这个的模块，就可以得到 module.exports</span></span><br><span class="line"><span class="comment">// 在node最底层</span></span><br><span class="line"><span class="comment">// 还有一句</span></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports</span><br><span class="line"><span class="comment">// 默认在代码的最后 ：</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure>



<h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p><strong>node package manager</strong></p>
<h4 id="npm-网站"><a href="#npm-网站" class="headerlink" title="npm 网站"></a>npm 网站</h4><p>npmjs.com</p>
<h4 id="npm-命令行工具"><a href="#npm-命令行工具" class="headerlink" title="npm 命令行工具"></a>npm 命令行工具</h4><p>只要安装了node ,就安装了npm</p>
<p>npm也有版本概念</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm --version     ## 查看版本</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --global npm     ## 升级npm</span><br></pre></td></tr></table></figure>

<h4 id="npm-常用命令"><a href="#npm-常用命令" class="headerlink" title="npm 常用命令"></a>npm 常用命令</h4><ul>
<li>npm init [–yes]<ul>
<li>npm init -y 跳过向导，快速生成</li>
</ul>
</li>
<li>npm install<ul>
<li>一次性把 dependencies 选项中的依赖项全部安装</li>
<li>npm i </li>
</ul>
</li>
<li>npm install 包名<ul>
<li>只下载</li>
<li>npm i 包名</li>
</ul>
</li>
<li>npm install 包名 –save<ul>
<li>下载并保存依赖项（ package.json 文件中的 dependencies 选项）</li>
<li>npm i -S 包名</li>
</ul>
</li>
<li>npm uninstall 包名<ul>
<li>只删除，如果有依赖项会依然保存</li>
<li>npm un 包名</li>
</ul>
</li>
<li>npm uninstall –save 包名<ul>
<li>删除的同时也会把依赖信息也去除</li>
<li>npm un -S 包名</li>
</ul>
</li>
<li>npm help <ul>
<li>查看使用帮助</li>
</ul>
</li>
<li>npm 命令 –help<ul>
<li>查看指定命令的使用帮助</li>
</ul>
</li>
</ul>
<h4 id="解决npm被墙问题"><a href="#解决npm被墙问题" class="headerlink" title="解决npm被墙问题"></a>解决npm被墙问题</h4><p>npm存储包文件的服务器在国外，有时候会被墙，速度很慢</p>
<p><a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a> 淘宝的开发团队，把npm在国内做了备份</p>
<p>步骤：</p>
<ol>
<li><p>安装淘宝的cnpm：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --global cnpm</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># --global表示安装到全局，而非当前目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 这条命令中 --global不能省略</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 所有需要用 --global 来安装的包都可以在任意目录执行</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装时包时将<code>npm</code> 替换成 <code>cnpm</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里还是走国外的npm服务器，速度比较慢</span></span><br><span class="line">npm install jquery</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 cnpm 通过淘宝的服务器下载</span></span><br><span class="line">cnpm install jquery</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不想安装 cnpm 又想使用淘宝的服务器来下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install jquery --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<ul>
<li><p>每次手动加参数过于繁琐，可以把这个选项加入配置文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看npm配置信息</span></span></span><br><span class="line">npm config list</span><br></pre></td></tr></table></figure>
</li>
<li><p>只要经过上面命令配置，以后所有的<code>npm install</code> 都会默认通过淘宝服务器来下载</p>
</li>
</ul>
</li>
</ol>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><ul>
<li><p>每个项目的根目录下都要有一个 package.json 文件 （包描述文件）</p>
</li>
<li><p>执行<code>npm install</code> 包名的时候都加上 –save，用来 保存依赖项信息</p>
</li>
<li><p>package.json 可以通过 <code>npm init</code>的方式自动初始化出来</p>
<ul>
<li><code>dependencies</code> 选项，保存第三方包的依赖信息</li>
</ul>
</li>
<li><p>若删除了node_modules 文件夹，且package.json 存在</p>
<ul>
<li>直接使用 <code>npm install</code> 找回<ul>
<li><code>npm install</code> 自动把package.json 中的dependencies 中所有的依赖项，都下载回来.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="package-json-和-package-lock-json"><a href="#package-json-和-package-lock-json" class="headerlink" title="package.json 和 package-lock.json"></a>package.json 和 package-lock.json</h4><p>npm5 以前是不会有 <code>package-lock.json</code> 这个文件的</p>
<p>npm5以后才加入的</p>
<p>当你安装包的时候，npm 都会生成或者更新 <code>package-lock.json</code> 这个文件</p>
<ul>
<li>npm5以后的版本安装包，不需要加 <code>--save</code> 参数，他会自动保存依赖信息</li>
<li>当安装包的时候，会自动创建或者是更新 <code>package-lock.json</code> 这个文件</li>
<li><code>package-lock.json</code> 会保存 <code>node_modules</code> 中所有包的信息（版本、下载地址）<ul>
<li>这样的话重新 <code>npm install</code> 的时候速度就可以提升</li>
</ul>
</li>
<li>从文件看来，有一个 <code>lock</code> 称之为 锁</li>
<li>这个<code>lock</code> 是用来锁定版本的</li>
<li>如果项目依赖1.1.1版本</li>
<li>你重新install 其实会下载最新版本，而不是1.1.1</li>
<li>我们的目的希望可以锁住1.1.1这个版本</li>
<li><code>package-lock.json</code>这个文件的另一个作用就是锁定版本号，防止自动升级到最新版本</li>
</ul>
<h2 id="path路径操作模块"><a href="#path路径操作模块" class="headerlink" title="path路径操作模块"></a>path路径操作模块</h2><blockquote>
<p>参考文档： <a href="https://nodejs.org/dist/latest-v12.x/docs/api/path.html" target="_blank" rel="noopener">https://nodejs.org/dist/latest-v12.x/docs/api/path.html</a> </p>
</blockquote>
<h3 id="常用API："><a href="#常用API：" class="headerlink" title="常用API："></a>常用API：</h3><ul>
<li><p>path.basename</p>
<ul>
<li>获取一个路径的文件名（默认包含扩展名）</li>
</ul>
</li>
<li><p>path.dirname</p>
<ul>
<li>获取一个路径中的目录部分</li>
</ul>
</li>
<li><p>path.extname</p>
<ul>
<li>获取一个路径中的扩展名部分</li>
</ul>
</li>
<li><p>path.parse</p>
<ul>
<li>把一个路径转为对象<ul>
<li>root 根路径</li>
<li>dir 目录</li>
<li>base 包含后缀名的文件名</li>
<li>ext 后缀名</li>
<li>name 不包含后缀名的文件名</li>
</ul>
</li>
</ul>
</li>
<li><p>path.isAbsolute </p>
<ul>
<li>判断一个路径是不是绝对路径</li>
</ul>
</li>
<li><p>path.join()</p>
<ul>
<li>作用：拼接路径</li>
<li>参数可以为任意，多写或者少写 <code>/</code> 不影响</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">path.join(<span class="string">'c:/a'</span>, <span class="string">'b'</span>)</span><br><span class="line">-- <span class="string">'c:\\a\\b'</span></span><br><span class="line"></span><br><span class="line">path.join(<span class="string">'c:/a'</span>, <span class="string">'/b'</span>, <span class="string">'c/'</span>, <span class="string">'./f'</span>)</span><br><span class="line">-- <span class="string">'c:\\a\\b\\c\\f'</span></span><br></pre></td></tr></table></figure>




</li>
</ul>
<p><img src="C:%5CUsers%5Canswer_zf%5CDesktop%5CSnipaste_2019-10-20_15-29-18.png" alt="Snipaste_2019-10-20_15-29-18"></p>
<h2 id="Node-中的其他成员"><a href="#Node-中的其他成员" class="headerlink" title="Node 中的其他成员"></a>Node 中的其他成员</h2><p>在每个模块中，出来 <code>require</code> 、<code>exports</code>等模块相关API之外，还有两个特殊的成员：</p>
<ul>
<li><code>__dirname</code> <strong>动态获取</strong> 当前文件模块所属目录的绝对路径</li>
<li><code>__filename</code> <strong>动态获取</strong> 当前文件的绝对路径</li>
<li><code>__dirname</code> 和 <code>__filename</code>  不受 node 命令所属路径影响</li>
</ul>
<h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h3><p>在文件操作路径中，相对路径设计的就是相对于执行 node 命令所处的路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'./a.txt'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span>&#123;...&#125;)</span><br><span class="line">-- 相对于执行 node 命令所处的终端路径</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## ├─app.js</span><br><span class="line">## └─foo</span><br><span class="line">##    ├─a.txt</span><br><span class="line">##    └─index.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'./a.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">--------------------------- index.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fooIndex = <span class="built_in">require</span>(<span class="string">'./foo/index'</span>)</span><br><span class="line">--------------------------- app.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在app.js 当前目录执行终端 则加载不到 a.txt</span></span><br></pre></td></tr></table></figure>

<p>在文件操作中，使用相对路径是不可靠的，因为在 Node 中文操作的路径被设计为相对于执行 node 命令所处的路径。（不是 bug ）</p>
<p>为了解决这个问题：把相对路径变为绝对路径即可</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>可以使用 <code>__dirname</code> 或者 <code>__filename</code> 解决问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(__dirname + <span class="string">'/a.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;   <span class="comment">// node 执行中会把 / 转为 \</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">--------------------------- index.js</span><br></pre></td></tr></table></figure>

<p>在拼接路径的过程中，为了避免手动拼接带来的低级错误，推荐多使用, <code>path.join()</code>来辅助拼接。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(path.join(__dirname, <span class="string">'./a.txt'</span>), <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">--------------------------- index.js</span><br></pre></td></tr></table></figure>



<p> 为了尽量避免前面所描述的问题，以后文件操作中使用的相对路径都统一转换为 <strong>动态的绝对路径</strong>。</p>
<blockquote>
<p>补充： 模块中的路径标识和文件操作中的相对路径标识，不一样</p>
<p>​            模块中的路径标识就是相对于当前文件模块就，不受执行 node 命令所处路径影响</p>
</blockquote>
<h2 id="Node-Express"><a href="#Node-Express" class="headerlink" title="Node_Express"></a>Node_Express</h2><p><strong>原生的http在某些方面不足以应对我们对开发的需求，需要使用框架加快开发效率，框架的目的就是提高效率，让代码更高度统一。</strong></p>
<p><strong>在 Node 中有很多web开发框架，Express是其中一种</strong>     <a href="http://expressjs.com/" target="_blank" rel="noopener">http://expressjs.com/</a></p>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save express</span><br></pre></td></tr></table></figure>



<h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="comment">// 创建app   =&gt;相当于 http.creataServer</span></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">5000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'express app is running...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="基本路由-router"><a href="#基本路由-router" class="headerlink" title="基本路由 router"></a>基本路由 router</h4><p>路由</p>
<ul>
<li>请求方法</li>
<li>请求路径</li>
<li>请求处理函数</li>
</ul>
<p>get：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当以 get 方法请求 / 的时候，执行对应的处理函数 =&gt; 路由 / 映射关系</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>post:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当以 post 方法请求 / 的时候，执行对应的处理函数 =&gt; 路由 / 映射关系</span></span><br><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Got a POST request'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>重定向：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.redirect(<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">## └─Project Directory</span><br><span class="line">##    └─public</span><br><span class="line">## 			 └─main.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当以 /public/ 开头的时候 ，去 ./public/ 目录中 查找对应的资源</span></span><br><span class="line">app.use('/public/', express.static('./public/'))      ## 推荐</span><br><span class="line">--------</span><br><span class="line">## 访问路径：http://127.0.0.1:5000/public/main.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当省略第一个参数的时候，可以通过省略/public的方式来访问</span></span><br><span class="line">app.use(express.static(<span class="string">'./public/'</span>))</span><br><span class="line">--------</span><br><span class="line">## 访问路径：http://127.0.0.1:5000/main.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// /a 相当于 /public的别名</span></span><br><span class="line">app.use(<span class="string">'/static/'</span>, express.static(<span class="string">'./public/'</span>))</span><br><span class="line">--------</span><br><span class="line">## 访问路径：http://127.0.0.1:5000/static/main.js</span><br></pre></td></tr></table></figure>

<h4 id="在Express中获取表单-GET请求参数"><a href="#在Express中获取表单-GET请求参数" class="headerlink" title="在Express中获取表单 GET请求参数"></a>在Express中获取表单 GET请求参数</h4><p>Express内置了一个API，可以直接通过 <code>req.query</code> 来获取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.query</span><br></pre></td></tr></table></figure>

<h4 id="在Express中获取表单-POST-请求体数据"><a href="#在Express中获取表单-POST-请求体数据" class="headerlink" title="在Express中获取表单 POST 请求体数据"></a>在Express中获取表单 POST 请求体数据</h4><p>在Express中没有内置获取表单 POST 请求体的API，需要主要使用第三方包：<code>body-parser</code> 中间件（插件，专门用来解析表单 post 请求体）</p>
<p>安装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save body-parser</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 body-parser</span></span><br><span class="line"><span class="comment">// 加入这个配置后,则在 req 请求对象上会多出来一个属性： body</span></span><br><span class="line"><span class="comment">// 通过 req.body 获取表单 POST 请求体数据</span></span><br><span class="line"><span class="comment">// parse application/x-www-form-urlencoded</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line"><span class="comment">// parse application/json</span></span><br><span class="line">app.use(bodyParser.json())</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>)</span><br><span class="line">  res.write(<span class="string">'you posted:\n'</span>)</span><br><span class="line">  <span class="comment">// 可以通过 req.body 来获取表单 POST 请求体数据</span></span><br><span class="line">  res.end(<span class="built_in">JSON</span>.stringify(req.body, <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><h5 id="Express-中的-json-方法"><a href="#Express-中的-json-方法" class="headerlink" title="Express 中的 json 方法"></a>Express 中的 json 方法</h5><ul>
<li>该方法接收一个对象作为参数，自动把对象转为字符串，在发送给浏览器</li>
</ul>
<h3 id="在Express中配置使用art-template模板引擎"><a href="#在Express中配置使用art-template模板引擎" class="headerlink" title="在Express中配置使用art-template模板引擎"></a>在Express中配置使用art-template模板引擎</h3><ul>
<li><p><a href="https://github.com/aui/art-template" target="_blank" rel="noopener">art-template - GitHub 仓库</a></p>
</li>
<li><p><a href="https://aui.github.io/art-template/zh-cn/index.html" target="_blank" rel="noopener">art-template - 官方文档</a></p>
</li>
</ul>
<h4 id="安装：-1"><a href="#安装：-1" class="headerlink" title="安装："></a>安装：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save art-template</span><br><span class="line">npm install --save express-art-template</span><br></pre></td></tr></table></figure>

<h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.engine(<span class="string">'html'</span>, <span class="built_in">require</span>(<span class="string">'express-art-template'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// express 默认会去项目中的 views 目录中找 index.html</span></span><br><span class="line">  <span class="comment">// render方法 =&gt; 渲染文件 详解见说明</span></span><br><span class="line">  res.render(<span class="string">'index.html'</span>, &#123;</span><br><span class="line">     title: <span class="string">'hello world'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果希望修改默认的 <code>views</code> 视图渲染存储目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意第一个参数 views 千万不能错</span></span><br><span class="line">app.set(<span class="string">'views'</span>, 目录路径)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h4><ul>
<li><p><strong>配置art-template 模板引擎</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.engine(<span class="string">'art'</span>, <span class="built_in">require</span>(<span class="string">'express-art-template'</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数表示：当渲染以 .art 结尾的文件的时候，使用 art-template 模板引擎<ul>
<li>个人习惯 <code>app.engine(&#39;html&#39;, require(&#39;express-art-template&#39;))</code></li>
</ul>
</li>
<li>express-art-template 是专门用来在 Express 中 把 art-template 整合到 Express中</li>
<li>虽然这里不需要加载 art-template 但是也必须安装</li>
<li>原因是 express-art-template 依赖了 art-template</li>
</ul>
</li>
<li><p><strong>使用art-template 模板引擎</strong></p>
<ul>
<li>Express 为 Response 相应对象提供了一个方法：render</li>
<li>render 方法默认是不可以使用的，但是如果配置了模板引擎就可以使用了</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.render(<span class="string">'html模板名'</span>, &#123;模板数据&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数不能写路径，默认会去项目中的 views 目录查找该模板文件</li>
<li>Express有个约定，开发人员把所有的视图文件都放到 views 目录中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'index.html'</span>)<span class="comment">// 若不需要模板引擎渲染，第二个参数不用传，直接渲染文件页面</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>若要访问 views 下目录中的文件，直接跳过 views/ 即可</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">## └─ views</span><br><span class="line">##    └─ admin</span><br><span class="line">## 			 └─ index.js</span><br><span class="line">app.get(<span class="string">'/admin'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'admin/index.html'</span>, &#123;</span><br><span class="line">    title: <span class="string">'index page'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Express-中配置使用-Express-session"><a href="#Express-中配置使用-Express-session" class="headerlink" title="Express 中配置使用 Express-session"></a>Express 中配置使用 Express-session</h3><p>express 中默认不支持 session 和 cookie，使用第三方中间件 <code>express-session</code>解决</p>
<p>安装： </p>
<p><code>npm install express-session</code></p>
<p>配置：（必须在 app.use(router)之前）</p>
<ul>
<li>该插件会为 req 请求对象添加一个成员：<code>req.session</code>，默认是一个对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  <span class="comment">// 配置加密字符串，会在原有加密基础之上，和这个字符串拼起来去加密</span></span><br><span class="line">  <span class="comment">// 目的为了增加安全性，防止客户端恶意伪造</span></span><br><span class="line">  secret: <span class="string">'keyboard cat'</span>, </span><br><span class="line">  resave: <span class="literal">false</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">true</span> <span class="comment">// 无论是否使用 session ，默认直接分配一把钥匙（空 session ）</span></span><br><span class="line">  												<span class="comment">// false：存数据的时候才会分配钥匙</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<ul>
<li>可以通过 req.session 来发访问和设置 Session 成员<ul>
<li>添加 session 数据：<ul>
<li>req.session.foo = ‘bar’</li>
</ul>
</li>
<li>获取 session 数据：<ul>
<li>req.session.foo</li>
</ul>
</li>
<li>删除 session 数据：<ul>
<li>req.session.foo = null</li>
<li>更严谨的做法使用 <code>delete</code> 语法<ul>
<li>delete req.session.foo</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>提示：默认Session 数据是内存存储的，服务器一旦存储就会丢失，真正的生产环境会把 Session 进行持久化存储。</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p> <a href="http://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener">http://expressjs.com/en/guide/using-middleware.html</a> </p>
<p>![1-130I0234953631](media/NodeJS. assets/1-130I0234953631.png)</p>
<p>中间件的本质就是一个请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，这样做的目的是提高代码的灵活性，动态可扩展。</p>
<ul>
<li>同一个请求所经过的中间件都是同一个请求对象和响应对象。</li>
</ul>
<h4 id="中间件匹配机制"><a href="#中间件匹配机制" class="headerlink" title="中间件匹配机制"></a>中间件匹配机制</h4><p>当请求进来，会从第一个中间件开始进行匹配</p>
<ul>
<li><p>如果匹配，则进来</p>
</li>
<li><p>如果请求进入中间件之后，没有调用 next 则代码会停在当前中间件</p>
</li>
<li><p>如果调用了 next 则继续向后找到第一个匹配的中间件</p>
</li>
<li><p>如果不匹配，则继续判断匹配下一个中间件</p>
</li>
<li><p>如果没有能匹配的中间件，则 Express 会默认输出：Cannot GET 路径</p>
</li>
</ul>
<h4 id="中间件类目"><a href="#中间件类目" class="headerlink" title="中间件类目"></a>中间件类目</h4><h5 id="应用程序级别中间件"><a href="#应用程序级别中间件" class="headerlink" title="应用程序级别中间件"></a>应用程序级别中间件</h5><p>万能匹配（不关心任何请求路径和请求方法）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中间件本身是一个方法，该方法接收三个参数：</span></span><br><span class="line"><span class="comment">//    Request 请求对象</span></span><br><span class="line"><span class="comment">//    Response 响应对象</span></span><br><span class="line"><span class="comment">//    next     下一个中间件</span></span><br><span class="line"><span class="comment">// 当一个请求进入一个中间件之后，如果不调用 next 则会停留在当前中间件</span></span><br><span class="line"><span class="comment">// 所以 next 是一个方法，用来调用下一个中间件的</span></span><br><span class="line"><span class="comment">// 调用 next 方法也是要匹配的（不是调用紧挨着的那个）</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Time:'</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>只要是以 <code>/xxx/</code> 开头的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Time:'</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="路由级别中间件"><a href="#路由级别中间件" class="headerlink" title="路由级别中间件"></a>路由级别中间件</h5><p>get:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	res.send(<span class="string">'Hello World!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>post:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	res.send(<span class="string">'Got a POST request'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>put:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.put(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	res.send(<span class="string">'Got a PUT request at /user'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>delete:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.delete(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	res.send(<span class="string">'Got a DELETE request at /user'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.error(err.stack)</span><br><span class="line">	res.status(<span class="number">500</span>).send(<span class="string">'Something broke!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h5><ul>
<li><a href="http://expressjs.com/en/4x/api.html#express.static" target="_blank" rel="noopener">express.static</a> serves static assets such as HTML files, images, and so on.</li>
<li><a href="http://expressjs.com/en/4x/api.html#express.json" target="_blank" rel="noopener">express.json</a> parses incoming requests with JSON payloads. <strong>NOTE: Available with Express 4.16.0+</strong></li>
<li><a href="http://expressjs.com/en/4x/api.html#express.urlencoded" target="_blank" rel="noopener">express.urlencoded</a> parses incoming requests with URL-encoded payloads. <strong>NOTE: Available with Express 4.16.0+</strong></li>
</ul>
<h5 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h5><p> <a href="http://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener">http://expressjs.com/en/guide/using-middleware.html</a> </p>
<ul>
<li><p><a href="http://expressjs.com/en/resources/middleware/body-parser.html" target="_blank" rel="noopener">body-parser</a> </p>
</li>
<li><p><a href="http://expressjs.com/en/resources/middleware/compression.html" target="_blank" rel="noopener">compression</a> </p>
</li>
<li><p><a href="http://expressjs.com/en/resources/middleware/cookie-parser.html" target="_blank" rel="noopener">cookie-parser</a> </p>
</li>
<li><p><a href="http://expressjs.com/en/resources/middleware/morgan.html" target="_blank" rel="noopener">morgan</a> </p>
</li>
<li><p><a href="http://expressjs.com/en/resources/middleware/response-time.html" target="_blank" rel="noopener">response-time</a> </p>
</li>
<li><p><a href="http://expressjs.com/en/resources/middleware/serve-static.html" target="_blank" rel="noopener">serve-static</a> </p>
</li>
<li><p><a href="http://expressjs.com/en/resources/middleware/session.html" target="_blank" rel="noopener">session</a> </p>
</li>
</ul>
<h4 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h4><h5 id="配置处理-404-的中间件"><a href="#配置处理-404-的中间件" class="headerlink" title="配置处理 404 的中间件"></a>配置处理 404 的中间件</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在项目入口文件的最后（app.listen之前）</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">'404.html'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="配置全局处理中间件"><a href="#配置全局处理中间件" class="headerlink" title="配置全局处理中间件"></a>配置全局处理中间件</h5><ul>
<li><p>当调用 next 的时候，如果传递了参数，则直接往后找到带有 四个参数的应用程序级别中间件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在项目入口文件的最后（app.listen之前）</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  res.status(<span class="number">500</span>).send(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当发生错误的时候，我们可以调用 next 传递错误对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">  <span class="keyword">return</span> next(err) <span class="comment">// 省去大量重复代码</span></span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就会被全局错误处理中间件匹配到并处理之</p>
</li>
</ul>
<h2 id="crud案例"><a href="#crud案例" class="headerlink" title="crud案例"></a>crud案例</h2><h3 id="模块化思想"><a href="#模块化思想" class="headerlink" title="模块化思想"></a>模块化思想</h3><p>模块符合划分：</p>
<ul>
<li>模块职责要单一</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p> <a href="https://github.com/asnwer-zf/nodeText_express_crud" target="_blank" rel="noopener">https://github.com/asnwer-zf/nodeText_express_crud</a> </p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="回调函数：获取异步操作结果"><a href="#回调函数：获取异步操作结果" class="headerlink" title="回调函数：获取异步操作结果"></a>回调函数：获取异步操作结果</h3><p><del>不成立情况：</del></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">var</span> ret = x + y</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 到这里执行结束，不会等到前面的定时器，所以直接返回默认值 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">20</span>)) <span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>

<p><del>不成立情况：</del></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">var</span> ret = x + y</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">20</span>)) <span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>如果需要获取一个函数异步操作的结果，必须使用回调函数来获取</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// callback 就是回调函数</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = x + y</span><br><span class="line">       	callback(ret)  <span class="comment">// ret -&gt; 实参</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ret</span>) </span>&#123;  <span class="comment">// ret -&gt; 形参</span></span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>基于原生XMLHTTPRequest封装get 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oReq = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  <span class="comment">// 当请求加载成功之后要调用指定的函数</span></span><br><span class="line">  oReq.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(oReq.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">  oReq.open(<span class="string">"get"</span>, url, <span class="literal">true</span>)</span><br><span class="line">  oReq.send()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span>('data.json', function (data) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<ul>
<li><p>异步API 一般都 伴随着回调函数(上层定义，下层调用)</p>
<ul>
<li>setTimeout</li>
<li>readFile</li>
<li>writeFile</li>
<li>readdir</li>
<li>ajax</li>
</ul>
</li>
<li><p>a 链接默认是同步请求</p>
</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><blockquote>
<p> 参考文档：<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise</a> </p>
</blockquote>
<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>callbackhell：</p>
<p>![callbackhell](media/NodeJS. assets/callbackhell.jpg)</p>
<p>无法保证顺序的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/a.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// return console.log('读取失败')</span></span><br><span class="line">    <span class="comment">// 抛出异常（做测试的时候经常使用）</span></span><br><span class="line">    <span class="comment">//    1. 阻止程序的执行 （程序奔溃直接退出）</span></span><br><span class="line">    <span class="comment">//    2. 把错误消息打印到控制台</span></span><br><span class="line">    <span class="keyword">throw</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/b.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/c.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过回调嵌套的方式来保证顺序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./data/a.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">  fs.readFile(<span class="string">'./data/b.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    fs.readFile(<span class="string">'./data/c.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123; <span class="keyword">throw</span> err &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为了解决以上编码方式带来的问题（回调地狱嵌套），在Ecamscript 6 中新增了一个API：<code>Promise</code></p>
<h4 id="Promise基本语法"><a href="#Promise基本语法" class="headerlink" title="Promise基本语法"></a>Promise基本语法</h4><ul>
<li>Promise  -  承诺、保证</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="comment">// promise是一个构造函数</span></span><br><span class="line"><span class="comment">// 不是异步，但里面往往封装一个异步任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Promise 容器</span></span><br><span class="line"><span class="comment">// Promise 容器一旦创建，就开始执行里面的代码</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile('./data/a.txt', 'utf8', function(err, data) &#123;  ## 异步任务</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 承诺容器中的任务失败，</span></span><br><span class="line">      <span class="comment">// console.log(err)</span></span><br><span class="line">      <span class="comment">// 把容器中的 Pending 状态变为 rejected</span></span><br><span class="line">      <span class="comment">// 调用 reject 就相当于调用了 then 方法的第二个参数</span></span><br><span class="line">      reject(err)  ## 失败调用</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 承诺容器中的任务成功，</span></span><br><span class="line">      <span class="comment">// console.log(data)</span></span><br><span class="line">      <span class="comment">// 把容器中的 Pending 状态变为 resolved</span></span><br><span class="line">      <span class="comment">// 调用 resolve 就相当于调用了 then 方法的传递的那个function</span></span><br><span class="line">      resolve(data)  ## 成功调用</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 p1 成功了 然后（then） 做指定操作</span></span><br><span class="line"><span class="comment">// then 方法接收的 function 就是容器中的 resolve 函数</span></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h4 id="Promise的封装"><a href="#Promise的封装" class="headerlink" title="Promise的封装"></a>Promise的封装</h4><p>实例推导（ readFile ）</p>
<ul>
<li>异步调用链式编程</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'./data/a.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="regexp">/...</span></span><br><span class="line"><span class="regexp">var p3 = /</span>...</span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="comment">// 当 p1 读取成功的时候</span></span><br><span class="line">    <span class="comment">// 当前函数中 return 的结果就可以在后面的 then 中 function 接收到，故：</span></span><br><span class="line">    <span class="comment">// 当 return 123 后面就接收到 123</span></span><br><span class="line">    <span class="comment">// 没有 return 后面就接收的是 undefined</span></span><br><span class="line">    <span class="comment">// 同理可以 return 一个 Promise 对象</span></span><br><span class="line">    <span class="comment">// 当 return 一个Promise 对象的时候，后续的then中的 方法的第一个参数会作为p2 的 resolve</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> p3</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



<p>![Snipaste_2019-10-19_15-40-57](media/NodeJS. assets/Snipaste_2019-10-19_15-40-57.jpg)</p>
<p>=&gt;  封装实例    promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pReadFile</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filePath, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">pReadFile(<span class="string">'./data/a.txt'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> pReadFile(<span class="string">'./data/b.txt'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> pReadFile(<span class="string">'./data/c.txt'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2><h3 id="修改完成代码自动重启"><a href="#修改完成代码自动重启" class="headerlink" title="修改完成代码自动重启"></a>修改完成代码自动重启</h3><p><strong>第三方命令行工具<code>nodemon</code>，可以解决频繁修改代码重启服务器问题</strong></p>
<p><strong><code>nodemon</code>是基于node.js开发的第三方命令行工具，需要独立安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 所有需要用 --global 来安装的包都可以在任意目录执行</span></span></span><br><span class="line">npm install --global nodemon</span><br></pre></td></tr></table></figure>

<p><strong>安装完毕以后，使用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node app.js</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 执行 nodemon 替换 node</span></span></span><br><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure>

<p><strong>通过 <code>nodemon</code> 启动的服务，会监视文件变化，当文件发生变化，自动重启服务器</strong></p>
<h3 id="文件操作中的-与模块标识中的"><a href="#文件操作中的-与模块标识中的" class="headerlink" title="文件操作中的 / 与模块标识中的 /"></a>文件操作中的 <code>/</code> 与模块标识中的 <code>/</code></h3><ul>
<li>*<em>文件标识中的路径可以省略 <code>./</code> *</em></li>
<li><strong>在模块加载中，相对路径中的 <code>./</code> 不能省略</strong></li>
</ul>
<h3 id="快捷创建服务"><a href="#快捷创建服务" class="headerlink" title="快捷创建服务"></a>快捷创建服务</h3><h4 id="http-server"><a href="#http-server" class="headerlink" title="http-server"></a>http-server</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g http-server@0.9.0 ## 新版本报错</span><br></pre></td></tr></table></figure>

<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hs -c-l -o</span><br></pre></td></tr></table></figure>

<h4 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h4><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g json-server</span><br></pre></td></tr></table></figure>

<h5 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">json-server --watch 文件名</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime</title>
    <url>/2019/11/01/sublime/</url>
    <content><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 汉化插件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> Localization</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 格式化代码插件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> JSFormat							<span class="comment">## js  格式化代码    shift+alt+j</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> HTML-CSS-JS Prettify				<span class="comment">## html格式化代码	shift+alt+h</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> CodeFormatter						<span class="comment">## 通用格式化代码	   shift+alt+f </span></span></span><br><span class="line">			   ---------------------</span><br><span class="line">									## sublime 只支持php5.6-php7.2的php版本</span><br><span class="line">									## 更改配置信息：</span><br><span class="line">									## "php_path": "C:/Develop/php-7.1.31/php.exe",</span><br><span class="line">									</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 侧边栏优化插件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> SideBarEnhancements				<span class="comment">## 具体配置见注释</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 最牛逼的插件：</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> Emmet                             <span class="comment">## 牛逼到不用解释！</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 代码颜色插件：</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> Color Highlighter</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 最棒的注释插件：</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> DocBlockr                         <span class="comment">## 快捷键：/** + enter</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 括号匹配插件：</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> Bracket Highlighter</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 快捷文件名输入插件：</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> AutoFileName</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 等号对其插件：</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> Alignment							<span class="comment">## 快捷键：alt+shift+e</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 转码插件：</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ConvertToUTF8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 头部注释插件：</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> FILE HEADER                       <span class="comment">## 自定义创建头部注释（详情配置见备注）</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 语法错误检测插件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sublimelinter 					<span class="comment">## 错误日志视图快捷键： ctrl+k,ctrl+e</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sublimelinter-php 				<span class="comment">## 具体见备注</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> SublimeLinter-jshint</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> SublimeLinter-csslint</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># PHP调试插件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> Xdebug Client</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主题预览插件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> colorsublime</span></span><br></pre></td></tr></table></figure>



<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 配色:			Dracula</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主题:			Materialize</span></span></span><br></pre></td></tr></table></figure>



<h1 id="首选项配置"><a href="#首选项配置" class="headerlink" title="首选项配置"></a>首选项配置</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 状态栏编码显示</span><br><span class="line">$ "show_encoding":true</span><br></pre></td></tr></table></figure>



<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p><strong>SUBLIMELINTER配置</strong>     ==&gt;     基于node插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">------js/css检测	## 安装环境</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1.安装node.js</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 2.命令行输入 </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#   2.1 js  检测</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g jshint            <span class="comment">##	SublimeLinter-jshint</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jshint -v						   <span class="comment">##   命令行输出："jshint v2.10.2"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#   2.2 css 检测</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g csslint           <span class="comment">##	SublimeLinter-csslint</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> csslint --version				   <span class="comment">##   命令行输出："v1.0.4"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------php检测  	 ## 配置环境</span><br><span class="line"></span><br><span class="line">​```json</span><br><span class="line"></span><br><span class="line">    "lint_mode": "save only",</span><br><span class="line"></span><br><span class="line">    "paths": &#123;</span><br><span class="line">        "linux": [],</span><br><span class="line">        "osx": [],</span><br><span class="line">        "windows": ["C:/Develop/php"]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>FILE HEADER配置</strong> </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 1.设置配置文件</span><br><span class="line">        </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Default"</span>:</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="attr">"email"</span>: <span class="string">"657829956@qq.com"</span>,</span><br><span class="line">       <span class="attr">"last_modified_by"</span>: <span class="string">"answer-zf"</span>,</span><br><span class="line">       <span class="attr">"author"</span>: <span class="string">"answe-zf"</span></span><br><span class="line">   &#125;</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line">## <span class="number">2.</span>自定义注释</span><br><span class="line"></span><br><span class="line">## 	<span class="number">2.1</span>找到文件夹</span><br><span class="line"></span><br><span class="line">	C:\Users\Administrator\AppData\Roaming\Sublime Text <span class="number">3</span>\</span><br><span class="line">    Packages\FileHeader\template\header</span><br><span class="line">    </span><br><span class="line">## 	<span class="number">2.2</span>在文件夹里找到需要修改的文件，并修改（以html文件为例）</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    * @Author: &#123;&#123;author&#125;&#125;</span><br><span class="line">    * @Date:   &#123;&#123;create_time&#125;&#125;</span><br><span class="line">    * @Last Modified by:   &#123;&#123;last_modified_by&#125;&#125;</span><br><span class="line">    * @Last Modified time: &#123;&#123;last_modified_time&#125;&#125;</span><br><span class="line">    * @E-mail: &#123;&#123;email&#125;&#125;</span><br><span class="line">    --&gt;</span><br></pre></td></tr></table></figure>



<h2 id="快捷键配置"><a href="#快捷键配置" class="headerlink" title="快捷键配置"></a>快捷键配置</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[</span><br><span class="line">    //格式化快捷键配置</span><br><span class="line">    //--codeformatter快捷键配置</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"shift+alt+f"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"code_formatter"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    //--htmlprettify快捷键配置</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"alt+shift+h"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"htmlprettify"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    //--jsFormat快捷键设置</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"shift+alt+j"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"js_format"</span>,</span><br><span class="line">        <span class="attr">"context"</span>: [&#123;</span><br><span class="line">            <span class="attr">"key"</span>: <span class="string">"selector"</span>,</span><br><span class="line">            <span class="attr">"operator"</span>: <span class="string">"equal"</span>,</span><br><span class="line">            <span class="attr">"operand"</span>: <span class="string">"source.js,source.json"</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    //chorme 浏览器打开快捷键(浏览器地址需适配本机电脑)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"f2"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"side_bar_files_open_with"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: &#123;</span><br><span class="line">            <span class="attr">"paths"</span>: [],</span><br><span class="line">            <span class="attr">"application"</span>: <span class="string">"C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe"</span>,</span><br><span class="line">            <span class="attr">"extensions"</span>: <span class="string">".*"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //SublimeLinter快捷键配置</span><br><span class="line">    //--Lint this view</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+k"</span>, <span class="string">"ctrl+l"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"sublime_linter_lint"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    //--Show all errors</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"ctrl+k"</span>, <span class="string">"ctrl+e"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"sublime_linter_panel_toggle"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    //Alignment快捷键配置</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"keys"</span>: [<span class="string">"alt+shift+e"</span>],</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"alignment"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="设置配置"><a href="#设置配置" class="headerlink" title="设置配置"></a>设置配置</h2><h2 id="连体字"><a href="#连体字" class="headerlink" title="连体字"></a>连体字</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//连体字符设置</span><br><span class="line">"font_face": "Fira Code"</span><br><span class="line"></span><br><span class="line">## 常用编程字体：</span><br><span class="line">-- Consolas</span><br><span class="line">-- Fira Code</span><br><span class="line">-- Source Code Pro</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>git</title>
    <url>/2019/11/01/git/</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/Git" target="_blank" rel="noopener">维基百科 - Git</a></p>
<a id="more"></a>
<h2 id="Git-介绍"><a href="#Git-介绍" class="headerlink" title="Git 介绍"></a>Git 介绍</h2><ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">Git教程 - 廖雪峰</a></li>
<li><a href="http://git.oschina.net/progit/" target="_blank" rel="noopener">Pro Git</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener">git - 简明指南</a></li>
<li><a href="http://backlogtool.com/git-guide/cn/" target="_blank" rel="noopener">猴子都能懂的GIT入门</a></li>
</ul>
<h2 id="Git-使用交互流程"><a href="#Git-使用交互流程" class="headerlink" title="Git 使用交互流程"></a>Git 使用交互流程</h2><p>![git交互模型](media/Git_&amp;_GitHub. assets/git交互模型-1571974764974.png)</p>
<h2 id="安装和配置-Git-环境"><a href="#安装和配置-Git-环境" class="headerlink" title="安装和配置 Git 环境"></a>安装和配置 Git 环境</h2><p>下载地址：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p>
<h3 id="git-bash-常用命令"><a href="#git-bash-常用命令" class="headerlink" title="git-bash 常用命令"></a>git-bash 常用命令</h3><p>git-bash </p>
<h3 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找到目标文件夹并进入</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 右键  选择 Git Bash Here</span></span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">git init 项目名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> 自动创建 项目目录 并且 初始化git 仓库</span></span><br></pre></td></tr></table></figure>



<h3 id="配置个人信息"><a href="#配置个人信息" class="headerlink" title="配置个人信息"></a>配置个人信息</h3><p>在用户目录下生成 <code>.gitconfig</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方便每次备份将使用者信息备份起来，方便操作</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置用户名</span></span><br><span class="line">git config --global user.name "answer-zf"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置用户邮箱</span></span><br><span class="line">git config --global user.email "feng18255163789@gmail"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 gitk 图形查看工具中文显示默认编码（防止乱码）</span></span><br><span class="line">git config --global gui.encoding utf-8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看配置列表项</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>



<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="将文件备份到Git仓库中"><a href="#将文件备份到Git仓库中" class="headerlink" title="将文件备份到Git仓库中"></a>将文件备份到Git仓库中</h3><p><strong>操作 Git 的基本工作流程就是先修改文件，然后执行 <code>git add</code> 命令。</strong><br><strong><code>git add</code> 命令会把文件加入到暂存区，接着就可以执行 <code>git commit</code> 命令，将文件存入文档库，</strong><br><strong>从而形成一次历史记录。</strong></p>
<p><strong>暂存区：</strong></p>
<ul>
<li>可作为临时版本库</li>
<li>可将修改的多个文件分多次提交<ul>
<li>按照不同的修改分类提交</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先存放置暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add ./readme.md</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再提交到版本库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"complete the first function！"</span>    <span class="comment"># -m : 说明信息（便于查看）</span></span></span><br><span class="line"> </span><br><span class="line">----------------------</span><br><span class="line"><span class="meta"> 	#</span><span class="bash"> 不输入 -m 会进去vim编辑器环境输说明信息。</span></span><br><span class="line"><span class="meta"> 	#</span><span class="bash"> 在vim里输入说明信息后 Esc键 + :Wp 即可    <span class="comment"># w：保存 p：退出</span></span></span><br><span class="line"><span class="meta"> 	#</span><span class="bash"> 强制退出：Esc键 + :p</span></span><br><span class="line"> 	</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#**************************************************************************</span></span></span><br><span class="line"> 	</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把所有的文件存放到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --all</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add ./	<span class="comment"># 当前文件夹所有文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一次性把所有修改后的文件直接放到版本库中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --all -m <span class="string">"这是一次性操作"</span>        <span class="comment"># --all : 把所有修改后的文件直接放到版本库中</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 前提所有文件均被版本管理（提交过一次）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交 （修改commit的提交信息）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure>



<h3 id="删除、修改工作区文件"><a href="#删除、修改工作区文件" class="headerlink" title="删除、修改工作区文件"></a>删除、修改工作区文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>



<h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Changes not staged for commit</span></span><br><span class="line"><span class="comment"># modified （红色）  =&gt;  文件已修改，但未放入暂存区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Changes to be committed</span></span><br><span class="line"><span class="comment"># modified （绿色）  =&gt;  文件已经放入暂存区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nothing to commit, working tree clean  ==&gt; 文件已经在工作区</span></span><br></pre></td></tr></table></figure>



<h3 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看历史日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看精简日志，单行显示</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> **************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志过长会自动进入 less 查看模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看每次切换版本记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure>



<h3 id="打开图形界面"><a href="#打开图形界面" class="headerlink" title="打开图形界面"></a>打开图形界面</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gitk</span></span><br></pre></td></tr></table></figure>



<h3 id="撤销、回滚"><a href="#撤销、回滚" class="headerlink" title="撤销、回滚"></a>撤销、回滚</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ex-----------------------------------------</span></span><br><span class="line">$ git reset --hard Head~0    <span class="comment"># Head~0   回退到上一次提交代码时的状态</span></span><br><span class="line">							 <span class="comment"># Head~1   回退到上上一次提交代码时的状态</span></span><br><span class="line">							 </span><br><span class="line">							 <span class="comment"># hard     允许工作区代码被以前的代码覆盖</span></span><br><span class="line">							 </span><br><span class="line"><span class="comment"># 可以通过版本号精确回退到某一次提交的状态</span></span><br><span class="line">$ git reset --hard b0750f9   <span class="comment">## b0750f9 ：版本号</span></span><br><span class="line"><span class="comment"># -------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>



<h2 id="分支（-默认有一个主分支-master）"><a href="#分支（-默认有一个主分支-master）" class="headerlink" title="分支（ 默认有一个主分支 master）"></a>分支（ 默认有一个主分支 master）</h2><h3 id="分支基础"><a href="#分支基础" class="headerlink" title="分支基础"></a>分支基础</h3><p>默认在 git 的仓库中，会有个分支的原点：master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于当前分支新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于当前分支新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支，交替和上一个分支进行切换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并 指定分支 到 当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支(不能是当前所处分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于没有提交到暂存区的工作区的修改文件，无论切换到那个分支，内容不变，处于待提交到暂存区状态</li>
<li>对于没有提交到版本库的暂存区的文件，无论切换到那个分支，内容不变，处于待提交到版本库状态</li>
<li>也就是说 只有 commit 到的指定分支 才能对该分支进行操作</li>
</ul>
<h3 id="合并分支冲突"><a href="#合并分支冲突" class="headerlink" title="合并分支冲突"></a>合并分支冲突</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 在dev分支提交了代码以后</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 又在主分支master提交了代码</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 合并分支以后，需要手动处理，在提交到主分支中</span></span></span><br></pre></td></tr></table></figure>



<h2 id="Git-工作流程：分支策略"><a href="#Git-工作流程：分支策略" class="headerlink" title="Git 工作流程：分支策略"></a>Git 工作流程：分支策略</h2><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">Git 工作流程</a></p>
<h3 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h3><p><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git分支管理策略</a> </p>
<h3 id="Github-Collabrators"><a href="#Github-Collabrators" class="headerlink" title="Github Collabrators"></a>Github Collabrators</h3><p>这种方式公司团队项目使用居多</p>
<ul>
<li>进入项目</li>
<li>settings - &gt; Collaborators </li>
<li>添加 协作者 </li>
</ul>
<h3 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h3><p>这种方式开源项目使用居多</p>
<ul>
<li>fork</li>
<li>clone 到你的本地</li>
<li>在clone下来的项目中拉出一个新的分支<ul>
<li>修改的时候最好是基于 master 拉出一个修改的分支，例如这个分支是用来添加某个功能的</li>
</ul>
</li>
<li>在新分支上开发或者修改完成之后，提交到本地仓库，然后 push 推到自己的账户中 fork 过来的仓库</li>
<li>最后，在 Github 上你 fork 过来的仓库界面中找到 New Pull Request 发起提交请求</li>
<li>对方就会在仓库的 Pull Requests 中收到你发起的提交请求<ul>
<li>然后双方就可以使用社会化交流方式进行沟通协作</li>
<li>例如 Code Review 代码审查</li>
</ul>
</li>
<li>最后对方审查通过没有问题之后，选择 Merge Request</li>
<li>到此，一个完整的 Github 工作流结束</li>
<li>这种方式开源项目更多一些（大家都不认识）</li>
</ul>
<h3 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h3><h4 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h4><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">Gitlab</a></p>
<p>Gitlab 是一个开源的类似于 Github 的一个系统，开源免费部署到自己的公司内容。</p>
<h2 id="GIT-报错集合"><a href="#GIT-报错集合" class="headerlink" title="GIT 报错集合"></a>GIT 报错集合</h2><h3 id="将文件存放置暂存区警告："><a href="#将文件存放置暂存区警告：" class="headerlink" title="将文件存放置暂存区警告："></a>将文件存放置暂存区警告：</h3><blockquote>
<p>warning: LF will be replaced by CRLF in Config_Document/VS Code_Config/.vscode/settings.json.</p>
<p>The file will have its original line endings in your working directory</p>
</blockquote>
<p>解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global core.autocrlf <span class="literal">false</span></span></span><br></pre></td></tr></table></figure>



<h3 id="Git-Bash-中文乱码："><a href="#Git-Bash-中文乱码：" class="headerlink" title="Git Bash 中文乱码："></a>Git Bash 中文乱码：</h3><p>![Snipaste_2019-10-27_14-04-08](media/Git_&amp;_GitHub. assets/Snipaste_2019-10-27_14-04-08.png)</p>
<h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p><strong>让你使用社交化的方式进行编程协作</strong></p>
<p><strong>主要作用：</strong></p>
<ul>
<li>可以免费在线托管你的仓库</li>
<li>可以实现多人协作</li>
</ul>
]]></content>
      <categories>
        <category>Operate</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime_Operate</title>
    <url>/2019/11/01/Sublime-Operate/</url>
    <content><![CDATA[<h2 id="Dos-常用命令"><a href="#Dos-常用命令" class="headerlink" title="Dos 常用命令"></a>Dos 常用命令</h2><h3 id="CMD操作类"><a href="#CMD操作类" class="headerlink" title="CMD操作类"></a>CMD操作类</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切盘</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> D:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> del</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出dos</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exit</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空命令行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cls</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> &amp;&amp;   同时执行两个操作 用 &amp;&amp; 衔接</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h3 id="目录操作类"><a href="#目录操作类" class="headerlink" title="目录操作类"></a>目录操作类</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dir   <span class="comment">## 详细</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">创建目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> md 目录名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rd 目录名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rd /s/q 目录名   <span class="comment">## 强制删除文件文件夹和文件夹内所有文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入指定目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 目录名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">树形图显示目录结构</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br></pre></td></tr></table></figure>



<h3 id="文件操作类"><a href="#文件操作类" class="headerlink" title="文件操作类"></a>文件操作类</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重名名文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ren</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####	进阶操作  ==&gt;  批量重命名(指定字符串替换)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ren *.html *.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> replace</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> replace</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> del 文件名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> on &gt; a.txt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 向文件添加内容 （覆盖）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 内容 &gt; a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 向文件添加内容 （向后追加）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 追加 &gt;&gt; a.txt</span></span><br></pre></td></tr></table></figure>





<h3 id="服务操作类"><a href="#服务操作类" class="headerlink" title="服务操作类"></a>服务操作类</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sc query MySQL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> net start MySQL</span></span><br><span class="line">		</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> net stop MySQL</span></span><br><span class="line">		</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除服务</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sc delete MySQL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询端口情况</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -ano</span></span><br></pre></td></tr></table></figure>



<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Git Bash / Cmder 可以模拟Linux环境，在Windows操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 清屏</span></span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件夹列表 （显示不隐藏的文件与文件夹） </span></span><br><span class="line">ls</span><br><span class="line">ls -a  <span class="comment"># (显示当前目录下的所有文件及文件夹包括隐藏的.和..等)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作目录 </span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个文件或者目录</span></span><br><span class="line">rm 文件名</span><br><span class="line"><span class="comment"># 删除非空目录，以及一些比较顽固的文件或者目录</span></span><br><span class="line">rm -rf 目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">touch 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件（完整输出）</span></span><br><span class="line">cat 文件名</span><br><span class="line"><span class="comment"># 向文件添加内容 （覆盖）</span></span><br><span class="line">cat &gt; a.txt （回车后 添加内容）</span><br><span class="line"><span class="comment"># 向文件添加内容 （向后追加）</span></span><br><span class="line">cat &gt;&gt; a.txt （回车后 添加内容）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件（分页输出）-- 适用于查看大文本文件</span></span><br><span class="line">less 文件名 		<span class="comment"># b 向上翻一页    空格 向下翻一页    鼠标滚轮翻页</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># visual interface 编辑文本</span></span><br><span class="line">vi 文件名		<span class="comment"># 进去vi编辑模式</span></span><br><span class="line">Esc         <span class="comment"># 退出到命令模式</span></span><br><span class="line">i 					<span class="comment"># 进入插入模式</span></span><br><span class="line">:q 					<span class="comment"># 退出vi</span></span><br><span class="line">:w 					<span class="comment"># 保存编辑</span></span><br><span class="line">:wq 				<span class="comment"># 保存并退出</span></span><br><span class="line">:q! 				<span class="comment"># 强制退出不保存修改</span></span><br></pre></td></tr></table></figure>



<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sysdm.cpl  cmd 开启服务</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示桌面			==&gt;   win + D</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最小化所有窗口	  ==&gt;   win + M</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最小化除当前窗口以外所有窗口	==&gt;   win + HOME</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开资源管理器	  ==&gt;   win + E</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开设置	        ==&gt;   win + I</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 截图			 ==&gt;   win + PrintScreen</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 放大缩小视口	  ==&gt;   WIN + +/-</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换输入法    	   ==&gt;   WIN + space</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自定义截图		   ==&gt;   WIN + SHFIT +S</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">win + Ctrl + D       新建桌面</span><br><span class="line">win + Ctrl + 方向键   切换桌面</span><br><span class="line">win + tab						 列表</span><br></pre></td></tr></table></figure>



<h2 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a>Sublime</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令行 用 sublime 打开当前目录 .表示当前目录</span></span><br><span class="line">subl .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令行 用 vscode 打开当前目录</span></span><br><span class="line">code .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除整行  		==&gt;    CTRL + SHIFT + K </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 括号内部选中  	   ==&gt;    CTRL + SHIFT + M</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接跳下一行  	   ==&gt;    CTRL + ENTER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接跳上一行  	   ==&gt;    CTRL + SHIFT + ENTER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找选择器		    ==&gt;	   CTRL + R</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换同一个目录下所有文件公共部分</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ==&gt;侧边栏目录下子文件右键选项   Find Advanced  &gt;  In Parent Folder </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开所在目录		==&gt;    右击文件选  Reveal</span></span><br></pre></td></tr></table></figure>



<h2 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h2><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> console 命令行截图    ==&gt;     Capture node screenshot</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索栏技巧"><a href="#搜索栏技巧" class="headerlink" title="搜索栏技巧"></a>搜索栏技巧</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜索关键词如有空格，可用  <span class="string">""</span>  包含，视为一个词</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索限定</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> 关键词 + site:cnblogs.com</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 限定在 cnblogs.com 搜索</span></span><br></pre></td></tr></table></figure>



<h2 id="右键菜单分栏设置地址"><a href="#右键菜单分栏设置地址" class="headerlink" title="右键菜单分栏设置地址"></a>右键菜单分栏设置地址</h2><blockquote>
<p>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\</p>
</blockquote>
]]></content>
      <categories>
        <category>Operate</category>
      </categories>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
</search>
